# Copyright (C) 2022-2025 Exaloop Inc. <https://exaloop.io>

from threading import Lock
from time import time as _time, sleep as _sleep
import internal.gc as gc

_FUTURE_STATE_PENDING:   Literal[int] = 0
_FUTURE_STATE_FINISHED:  Literal[int] = 1
_FUTURE_STATE_EXCEPTION: Literal[int] = 2
_FUTURE_STATE_CANCELLED: Literal[int] = 3

@tuple
class WorkItem:
    coro: cobj        # Coroutine handle
    task: cobj        # Raw Task pointer, or null
    result_size: int  # Size in bytes of enclosed Future/Task result

class WorkNode:
    work: WorkItem
    prev: Optional[WorkNode]
    next: Optional[WorkNode]

    def __init__(self, work: WorkItem):
        self.work = work
        self.prev = None
        self.next = None

@tuple
class Timer:
    work: WorkItem
    when: float

class LoopCallback:
    coro: cobj
    next: Optional[LoopCallback]

class EventLoop:
    lock: Lock
    work_head: Optional[WorkNode]
    work_tail: Optional[WorkNode]
    work_curr: Optional[WorkItem]
    timers: Ptr[Timer]
    timers_len: int
    timers_cap: int
    running: bool
    closed: bool
    stop_flag: bool

class Future:
    _result: R
    _exception: Optional[BaseException]
    _lock: Lock
    _loop: EventLoop
    _cancel_msg: str
    _done_callbacks: Ptr[cobj]
    _done_callbacks_len: int
    _done_callbacks_cap: int
    _state: int
    R: type

class Task(Static[Future[R]]):
    _name: str
    _coro: cobj
    _waiting_on: Optional[Task[None]]
    R: type

@extend
class WorkItem:
    def __new__(coro: cobj):
        return WorkItem(coro, cobj(), 0)

    def __new__(coro: Coroutine):
        return WorkItem(coro.__raw__(), cobj(), 0)

    def __new__(task: Task):
        data = task.__raw__()
        coro = task._coro
        result_size = gc.sizeof(task.R)
        return WorkItem(coro, data, result_size)

    def raw_task(self):
        @pure
        @derives
        @llvm
        def _bitcast(x: T, D: type, T: type) -> D:
            %y = bitcast {=T} %x to {=D}
            ret {=D} %y

        task = self.task
        if not task:
            return None

        # Skip over `result` field
        return _bitcast(task + self.result_size, Task[None])

class InvalidStateError(Exception):
    def __init__(self, message: str = ''):
        super().__init__(message)

class CancelledError(Exception):
    def __init__(self, message: str = ''):
        super().__init__(message)

async def _callback_wrapper(callback, *args):
    callback(*args)

# TODO: make thread-local
_current_loop: Optional[EventLoop] = None
_running_loop: Optional[EventLoop] = None

@tuple
class _EnterLoop:
    loop: EventLoop
    old_current_loop: Optional[EventLoop]
    old_running_loop: Optional[EventLoop]

    def __new__(loop: EventLoop):
        return _EnterLoop(loop, _current_loop, _running_loop)

    def __enter__(self):
        global _current_loop
        global _running_loop
        _current_loop = self.loop
        _running_loop = self.loop

    def __exit__(self):
        global _current_loop
        global _running_loop
        _current_loop = self.old_current_loop
        _running_loop = self.old_running_loop

@extend
class EventLoop:
    def __init__(self):
        TIMERS_CAP_INIT: Literal[int] = 8  # must be power of 2
        self.lock = Lock()
        self.work_head = None
        self.work_tail = None
        self.work_curr = None
        self.timers = Ptr[Timer](TIMERS_CAP_INIT)
        self.timers_len = 0
        self.timers_cap = TIMERS_CAP_INIT
        self.running = False
        self.stop_flag = False

    def _ensure_open(self):
        if self.closed:
            raise RuntimeError("Event loop is closed")

    def close(self):
        if self.closed:
            return
        self.stop()
        with self._lock:
            self.work_head = None
            self.work_tail = None
            self.timers = Ptr[Timer]()
            self.timers_len = 0
            self.timers_cap = 0
            self.closed = True

    def time(self):
        return _time()

    def stop(self):
        with self.lock:
            self.stop_flag = True

    def is_running(self):
        return self.running

    def is_closed(self):
        return self.closed

    def _call_soon(self, work: WorkItem):
        with self.lock:
            self._work_enqueue(work)

    def call_soon(self, callback, *args):
        self._call_soon(WorkItem(_callback_wrapper(callback, *args)))
        # TODO: return Handle

    def call_soon_threadsafe(self, callback, *args):
        with self.lock:
            return self.call_soon(callback, *args)

    def _call_later(self, work: WorkItem, delay: float):
        t = Timer(work, self.time() + delay)
        with self.lock:
            self._timers_push(t)

    def call_later(self, delay: float, callback, *args):
        self._call_later(WorkItem(_callback_wrapper(callback, *args)), delay)
        # TODO: return TimerHandle

    def call_at(self, delay: float, callback, *args):
        return self.call_later(delay, callback, *args)

    def _step(self):
        work: Optional[WorkItem] = None
        now = self.time()
        stop = False

        with self.lock:
            while self.timers_len > 0 and self.timers[0].when <= now:
                self._work_enqueue(self._timers_pop().work)

            if not self._work_empty():
                work = self._work_dequeue()
                self.work_curr = work

            stop = self.stop_flag

        if stop:
            return True

        if work is not None:
            g = Generator[None](work.coro)
            g.__resume__()

            if work.task:
                if g.__done__():
                    task = work.raw_task()
                    callbacks = Ptr[cobj]()
                    num_callbacks = 0
                    with task._lock:
                        str.memcpy(work.task,
                                   g.__promise__().as_byte(),
                                   int(work.result_size))
                        callbacks, num_callbacks = task._finish()
                    task._schedule_callbacks(callbacks, num_callbacks)
                else:
                    self._work_enqueue(work)

            self.work_curr = None
        else:
            sleep_time = 0.01  # 10ms default
            with self.lock:
                if self.timers_len > 0:
                    dt = self.timers[0].when - now
                    if dt > 0 and dt < sleep_time:
                        sleep_time = dt

            if sleep_time > 0:
                _sleep(sleep_time)

        return False

    def run_forever(self):
        self.running = True
        self.stop_flag = False
        with _EnterLoop(self):
            while True:
                stop = self._step()
                if stop:
                    break
            self.running = False

    def run_until_complete(self, future):
        self.running = True
        self.stop_flag = False
        with _EnterLoop(self):
            while not future.done():
                stop = self._step()
                if stop:
                    break
            self.running = False
        return future.result()

    def _work_empty(self):
        return self.work_tail is None

    def _work_enqueue(self, work: WorkItem):
        node = WorkNode(work)
        tail = self.work_tail

        if tail is None:
            self.work_head = node
            self.work_tail = node
            return

        node.prev = tail
        tail.next = node
        self.work_tail = node

    def _work_dequeue(self):
        # caller must ensure non-empty
        head = self.work_head
        self.work_head = head.next
        if head.next is None:
            self.work_tail = None
        else:
            head.next.prev = None
            head.next = None
        return head.work

    def _timers_reserve(self, new_cap: int):
        old_cap = self.timers_cap
        if new_cap <= old_cap:
            return

        sz = gc.sizeof(Timer)
        self.timers = gc.realloc(
                        self.timers.as_byte(),
                        new_cap * sz, old_cap * sz)
        self.timers_cap = new_cap

    def _timers_swap(self, i: int, j: int):
        timers = self.timers
        tmp = timers[i]
        timers[i] = timers[j]
        timers[j] = tmp

    def _timers_push(self, t: Timer):
        if self.timers_len == self.timers_cap:
            self._timers_reserve(self.timers_cap * 2)

        i = self.timers_len
        self.timers_len += 1
        timers = self.timers

        # Sift up
        while i > 0:
            parent = (i - 1) >> 1
            if timers[parent].when <= timers[i].when:
                break
            self._timers_swap(parent, i)
            i = parent

    def _timers_pop(self):
        if self.timers_len == 0:
            return None

        timers = self.timers
        out = timers[0]
        self.timers_len -= 1
        timers_len = self.timers_len

        if timers_len > 0:
            timers[0] = timers[timers_len]
            i = 0
            while True:
                left = 2*i + 1
                right = 2*i + 2
                smallest = i

                if (left < timers_len and timers[left].when < timers[smallest].when):
                    smallest = left
                if (right < timers_len and timers[right].when < timers[smallest].when):
                    smallest = right
                if smallest == i:
                    break

                self._timers_swap(i, smallest)
                i = smallest

        return out

    def create_future(self, T: type = NoneType):
        return Future[T](loop=self)

    def create_task(self, coro: Coroutine, name: Optional[str] = None):
        task = Task(coro, loop=self, name=name)
        work = WorkItem(task)
        self._call_soon(work)
        return task

@extend
class Future:
    def __init__(self, loop: Optional[EventLoop] = None):
        self._exception = None
        self._lock = Lock()
        if loop is None:
            self._loop = _running_loop
        else:
            self._loop = loop
        self._cancel_msg = ''
        self._done_callbacks = Ptr[cobj]()
        self._done_callbacks_len = 0
        self._done_callbacks_cap = 0
        self._state = _FUTURE_STATE_PENDING

    def _result_size(self):
        return gc.sizeof(R)

    def _reset_callbacks(self):
        if self._done_callbacks_cap > 0:
            gc.free(self._done_callbacks.as_byte())
        self._done_callbacks = Ptr[cobj]()
        self._done_callbacks_len = 0
        self._done_callbacks_cap = 0

    def _add_done_callback(self, coro: cobj):
        lock = self._lock
        lock.acquire()

        if self.done():
            lock.release()
            self._loop._call_soon(WorkItem(coro))
            return

        n = self._done_callbacks_len
        m = self._done_callbacks_cap

        if m == 0:
            self._done_callbacks = Ptr[cobj](1)
            self._done_callbacks_cap = 1
        elif n >= m:
            new_m = m * 2
            sz = gc.sizeof(cobj)
            self._done_callbacks = Ptr[cobj](
                                     gc.realloc(
                                       self._done_callbacks.as_byte(),
                                       new_m * sz, m * sz))
            self._done_callbacks_cap = new_m

        self._done_callbacks[n] = coro
        self._done_callbacks_len += 1
        lock.release()

    def _schedule_callbacks(self, callbacks: Ptr[cobj], num_callbacks: int):
        for i in range(num_callbacks):
            self._loop._call_soon(WorkItem(callbacks[i]))

    def result(self):
        with self._lock:
            state = self._state
            if state == _FUTURE_STATE_CANCELLED:
                raise CancelledError(self._cancel_msg)
            elif state == _FUTURE_STATE_EXCEPTION:
                raise self._exception.__val__()
            elif state == _FUTURE_STATE_PENDING:
                raise InvalidStateError("Result is not set.")
            else:
                return self._result

    def _finish(self):
        if self.done():
            raise InvalidStateError("Invalid state")

        self._state = _FUTURE_STATE_FINISHED
        callbacks = self._done_callbacks
        num_callbacks = self._done_callbacks_len
        self._reset_callbacks()
        return callbacks, num_callbacks

    def set_result(self, result: R):
        callbacks = Ptr[cobj]()
        num_callbacks = 0

        with self._lock:
            if self.done():
                raise InvalidStateError("Invalid state")

            self._result = result
            self._state = _FUTURE_STATE_FINISHED

            callbacks = self._done_callbacks
            num_callbacks = self._done_callbacks_len
            self._reset_callbacks()

        self._schedule_callbacks(callbacks, num_callbacks)

    def cancelled(self):
        return self._state == _FUTURE_STATE_CANCELLED

    def done(self):
        return self._state != _FUTURE_STATE_PENDING

    def cancel(self, msg: Optional[str] = None):
        callbacks = Ptr[cobj]()
        num_callbacks = 0

        with self._lock:
            if self.done():
                return False

            self._state = _FUTURE_STATE_CANCELLED
            if msg is not None:
                self._cancel_msg = msg

            callbacks = self._done_callbacks
            num_callbacks = self._done_callbacks_len
            self._reset_callbacks()

        self._schedule_callbacks(callbacks, num_callbacks)
        return True

    def get_loop(self):
        return self._loop

    def exception(self) -> Optional[BaseException]:
        with self._lock:
            state = self._state
            if state == _FUTURE_STATE_CANCELLED:
                raise CancelledError(self._cancel_msg)
            elif state == _FUTURE_STATE_EXCEPTION:
                return self._exception.__val__()
            elif state == _FUTURE_STATE_PENDING:
                raise InvalidStateError("Exception is not set.")
            else:
                return None

_default_task_name_counter = 1
def _default_task_name():
    global _default_task_name_counter
    n = _default_task_name_counter
    _default_task_name_counter += 1
    return f'Task-{n}'

@extend
class Task:
    def __init__(self,
                 coro: Coroutine[R],
                 loop: Optional[EventLoop] = None,
                 name: Optional[str] = None):
        super().__init__(loop)
        if name is None:
            self._name = _default_task_name()
        else:
            self._name = name
        self._coro = coro.__raw__()

    def get_name(self):
        return self._name

    def set_name(self, value: str):
        self._name = value

    def get_coro(self, T: type = NoneType) -> Coroutine[T]:
        return Coroutine[T](self._coro)

    def _add_done_callback(self, coro: cobj):
        pass

    def _schedule_callbacks(self, callbacks: Ptr[cobj], num_callbacks: int):
        super()._schedule_callbacks(callbacks, num_callbacks)

    def get_loop(self):
        return super().get_loop()

    def done(self):
        return super().done()

    def result(self):
        return super().result()

    def _finish(self):
        return super()._finish()

    def cancel(self, msg: Optional[str] = None):
        if not super().cancel(msg):
            return False

        with self._lock:
            waiting_on = self._waiting_on
            if waiting_on is not None:
                waiting_on.cancel(msg)
                self._waiting_on = None

def _wait_on_task(task):
    if not isinstance(task, Task):
        return

    loop = get_running_loop()
    if loop is not task.get_loop():
        raise RuntimeError("running loop is not the same as task loop")

    work_curr = loop.work_curr
    if work_curr is not None:
        task._waiting_on = work_curr.raw_task()

def new_event_loop():
    return EventLoop()

def set_event_loop(loop: EventLoop):
    global _current_loop
    _current_loop = loop

def get_event_loop():
    global _current_loop
    if _current_loop is not None:
        return _current_loop

    loop = new_event_loop()
    _current_loop = loop
    return loop

def get_running_loop() -> EventLoop:
    if _running_loop is None:
        raise RuntimeError("no running event loop")
    return _running_loop

def create_task(coro, name: Optional[str] = None):
    return get_running_loop().create_task(coro, name=name)

def run(coro, debug=None, loop_factory=None):
    if loop_factory is not None:
        loop = loop_factory()
    else:
        loop = get_event_loop()
    task = loop.create_task(coro)
    return loop.run_until_complete(task)
