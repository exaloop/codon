# Copyright (C) 2022-2026 Exaloop Inc. <https://exaloop.io>

# Methods for static reflection. Implemented within special.cpp, call.cpp and/or loops.cpp.
# !! Not intended for public use !!

def len(obj):
    pass

@no_argument_wrap
def print(*args):
    pass

def range(start: Literal[int], stop: Literal[int], step: Literal[int] = 1):
    import internal.types.range

    if step == 0:
        compile_error("range() step argument must not be zero")
    # Avoid exception raising method here as exception raising depends on this method
    return type._force_value_cast((start, stop, step), internal.types.range.range)

@overload
def range(stop: Literal[int]):
    import internal.types.range

    # Avoid exception raising method here as exception raising depends on this method
    return type._force_value_cast((0, stop, 1), internal.types.range.range)

def enumerate(tup):
    i = -1
    return tuple(((i := i + 1), t) for t in tup)
    i

def tuple(*args):
    return args

def has_rtti(T: type):
    pass

class function:
    def realized(fn, *args):
        pass

    def overloads(T: type, F: Literal[str]):
        pass

    def args(F):  # function: (i, name)
        pass

    def has_type(F, i: Literal[int]):
        pass

    def get_type(F, i: Literal[int]):
        pass

    @no_argument_wrap
    def can_call(F, *args, **kwargs):
        pass

    def wrap_args(F, *args, **kwargs):
        pass

    def has_default(F, i: Literal[int]):
        pass

    def get_default(F, i: Literal[int]):
        pass

def vars(obj, with_index: Literal[bool] = False):
    pass

def vars_types(T: type, with_index: Literal[bool] = False):
    pass

def tuple_type(T: type, N: Literal[int]):
    pass

# Compile-time generated
def format(fmt: Literal[str], arg: Literal[str]) -> Literal[str]:
    """%% is used instead of {} for arguments."""
    pass

# Compile-time generated
def int_to_string(val: Literal[int]) -> Literal[str]:
    pass

def loop_string(
    start: Literal[int], stop: Literal[int],
    val: Literal[str], delim: Literal[str]
) -> Literal[str]:
    if start >= stop:
        return ""
    elif start + 1 == stop:
        return static.format(val, int_to_string(start))
    else:
        return static.format(val, int_to_string(start)) + delim + loop_string(start + 1, stop, val, delim)
