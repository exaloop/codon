# Copyright (C) 2022-2025 Exaloop Inc. <https://exaloop.io>

# Warning(!): This type must be consistent with the exception
# header type defined in runtime/exc.cpp.
class BaseException:
    _pytype: ClassVar[cobj] = cobj()
    message: str
    func: str
    file: str
    line: int
    col: int
    python_type: cobj
    cause: Optional[BaseException]

    def __init__(self, message: str = ""):
        self.message = message
        self.func = ""
        self.file = ""
        self.line = 0
        self.col = 0
        self.python_type = BaseException._pytype
        self.cause = Optional._ref_new(T=BaseException)

    def __str__(self):
        return self.message

    def __repr__(self):
        return f'{self.typename}({self.message.__repr__()})'

    @property
    def __cause__(self):
        return self.cause

    @__hidden__
    def _set_header(e, func, file, line, col, cause):
        # if not isinstance(e, BaseException):
        #     compile_error("exceptions must derive from BaseException")

        e.func = func
        e.file = file
        e.line = line
        e.col = col
        if cause is not None:
            e.cause = cause
        return e


class Exception(BaseException):
    _pytype: ClassVar[cobj] = cobj()
    def __init__(self, message: str = ""):
        super().__init__(message)
        if hasattr(self.__class__, "_pytype"):
            self.python_type = self.__class__._pytype

class NameError(Exception):
    _pytype: ClassVar[cobj] = cobj()
    def __init__(self, message: str = ""):
        super().__init__(message)
        self.python_type = self.__class__._pytype

class OSError(Exception):
    _pytype: ClassVar[cobj] = cobj()
    def __init__(self, message: str = ""):
        super().__init__(message)
        self.python_type = self.__class__._pytype

class IOError(Exception):
    _pytype: ClassVar[cobj] = cobj()
    def __init__(self, message: str = ""):
        super().__init__(message)
        self.python_type = self.__class__._pytype

class ValueError(Exception):
    _pytype: ClassVar[cobj] = cobj()
    def __init__(self, message: str = ""):
        super().__init__(message)
        self.python_type = self.__class__._pytype

class LookupError(Exception):
    _pytype: ClassVar[cobj] = cobj()
    def __init__(self, message: str = ""):
        super().__init__(message)
        self.python_type = self.__class__._pytype

class IndexError(LookupError):
    _pytype: ClassVar[cobj] = cobj()
    def __init__(self, message: str = ""):
        super().__init__(message)
        self.python_type = self.__class__._pytype

class KeyError(LookupError):
    _pytype: ClassVar[cobj] = cobj()
    def __init__(self, message: str = ""):
        super().__init__(message)
        self.python_type = self.__class__._pytype

class CError(Exception):
    _pytype: ClassVar[cobj] = cobj()
    def __init__(self, message: str = ""):
        super().__init__(message)
        self.python_type = self.__class__._pytype

class TypeError(Exception):
    _pytype: ClassVar[cobj] = cobj()
    def __init__(self, message: str = ""):
        super().__init__(message)
        self.python_type = self.__class__._pytype

class ArithmeticError(Exception):
    _pytype: ClassVar[cobj] = cobj()
    def __init__(self, message: str = ""):
        super().__init__(message)
        self.python_type = self.__class__._pytype

class ZeroDivisionError(ArithmeticError):
    _pytype: ClassVar[cobj] = cobj()
    def __init__(self, message: str = ""):
        super().__init__(message)
        self.python_type = self.__class__._pytype

class OverflowError(ArithmeticError):
    _pytype: ClassVar[cobj] = cobj()
    def __init__(self, message: str = ""):
        super().__init__(message)
        self.python_type = self.__class__._pytype

class AttributeError(Exception):
    _pytype: ClassVar[cobj] = cobj()
    def __init__(self, message: str = ""):
        super().__init__(message)
        self.python_type = self.__class__._pytype

class RuntimeError(Exception):
    _pytype: ClassVar[cobj] = cobj()
    def __init__(self, message: str = ""):
        super().__init__(message)
        self.python_type = self.__class__._pytype

class NotImplementedError(RuntimeError):
    _pytype: ClassVar[cobj] = cobj()
    def __init__(self, message: str = ""):
        super().__init__(message)
        self.python_type = self.__class__._pytype

class StopIteration(Exception):
    _pytype: ClassVar[cobj] = cobj()
    def __init__(self, message: str = ""):
        super().__init__(message)
        self.python_type = self.__class__._pytype

class AssertionError(Exception):
    _pytype: ClassVar[cobj] = cobj()
    def __init__(self, message: str = ""):
        super().__init__(message)
        self.python_type = self.__class__._pytype

class EOFError(Exception):
    _pytype: ClassVar[cobj] = cobj()
    def __init__(self, message: str = ""):
        super().__init__(message)
        self.python_type = self.__class__._pytype

class SystemExit(BaseException):
    _pytype: ClassVar[cobj] = cobj()
    _status: int

    def __init__(self, message: str = "", status: int = 0):
        super().__init__(message)
        self._status = status
        self.python_type = self.__class__._pytype

    def __init__(self, status: int):
        self.__init__("", status)

    @property
    def status(self):
        return self._status

class StaticCompileError(Exception):
    def __init__(self, message: str = ""):
        super().__init__(message)
