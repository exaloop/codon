# Copyright (C) 2022-2025 Exaloop Inc. <https://exaloop.io>

import internal.static as static


def __type_repr__(T: type):
    return f"<class '{T.__name__}'>"


@extend
class type:
    @pure
    @derives
    @llvm
    def _force_cast(p, T: type) -> T:
        """
        Casts p of any reference type to the reference type T.

        This method is intented for the internal typechecking usage and is completely unsafe.
        No checks are performed; T is assumed to be a reference type.
        Any violations will result in LLVM errors.
        """
        ret ptr %p

    @pure
    @derives
    @llvm
    def _force_value_cast(t, U: type) -> U:
        """
        Casts t of any type to U. Used for casting tuples into named tuple types.

        This method is intented for the internal typechecking usage and is completely unsafe.
        No checks are performed; t is assumed to be byte-compatible with U.
        Any violations will result in LLVM errors.
        """
        ret {=U} %t

    @pure
    @derives
    @llvm
    def _ref_raw(obj) -> Ptr[byte]:
        """
        Casts the reference type to a pointer.
        """

        ret ptr %obj

    def _ref_new(T: type) -> T:
        """
        Allocates a new reference (class) object.
        """

        from internal.gc import alloc, alloc_atomic, sizeof, register_finalizer

        sz = sizeof(tuple(T))
        obj = alloc_atomic(sz) if T.__contents_atomic__ else alloc(sz)
        register_finalizer(obj)
        if static.has_rtti(T):
            obj = RTTIType._new(obj, TypeInfo(T), Ptr[byte])
        return type._force_cast(obj, T)

    def _construct(T: type, *args, **kwargs) -> T:
        """
        Shorthand for `t = T.__new__(); t.__init__(*args, **kwargs); t`
        """

        return T(*args, **kwargs)


@extend
class TypeInfo:
    def __new__(T: type) -> TypeInfo:
        id = T.__id__
        raw_name = f"{T}"
        nice_name = f"{T}"

        _repr = Function[[Ptr[byte]], str](cobj())
        if hasattr(T, "__repr__") or hasattr(T, "__str__"):
            fn = static.function.realized(TypeInfo.wrap(T=T, ...), Ptr[byte])
            if isinstance(fn.TR, str):
                _repr = fn

        return type._force_value_cast((id, raw_name, nice_name, _repr), TypeInfo)

    def wrap(arg: Ptr[byte], T: type) -> str:
        if isinstance(T, ByVal):
            p = type._force_cast(arg, Ptr[T])
            return repr(p[0])
        else:
            obj = type._force_cast(arg, T)
            return repr(obj)

    def __str__(self):
        return self.nice_name

    def __eq__(self, other: TypeInfo):
        return self.id == other.id

    def __ne__(self, other: TypeInfo):
        return self.id != other.id


@extend
class TypeWrap:
    def __new__(T: type) -> TypeWrap[T]:
        return type._force_value_cast((), TypeWrap[T])

    def __call_no_self__(*args, **kwargs) -> T:
        return T(*args, **kwargs)

    def __call__(self, *args, **kwargs) -> T:
        return T(*args, **kwargs)

    def __repr__(self):
        return __type_repr__(T)

    @property
    def __name__(self):
        return T.__name__


class __cast__:
    def cast(obj: T, T: type) -> Generator[T]:
        return obj.__iter__()

    @overload
    def cast(obj: int) -> float:
        return float(obj)

    @overload
    def cast(obj: T, T: type) -> Optional[T]:
        return Optional[T](obj)

    @overload
    def cast(obj: Optional[T], T: type) -> T:
        return obj.unwrap()

    @overload
    def cast(obj: T, T: type) -> pyobj:
        return obj.__to_py__()

    @overload
    def cast(obj: pyobj, T: type) -> T:
        return T.__from_py__(obj)

    # Function[[T...], R]
        # ExternFunction[[T...], R]
        # CodonFunction[[T...], R]
        # Partial[foo, [T...], R]

    # function into partial (if not Function) / fn(foo) -> fn(foo(...))
    # empty partial (!!) into Function[]
    # union extract
    # any into Union[]
    # derived to base

    def conv_float(obj: float) -> int:
        return int(obj)
