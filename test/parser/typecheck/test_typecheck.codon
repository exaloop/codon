#%% pass,barebones
pass

#%% print,barebones
print 1,
print 1, 2  #: 1 1 2

print 1, 2  #: 1 2
print(3, "4", sep="-", end=" !\n") #: 3-4 !

print(1, 2) #: 1 2
print (1, 2) #: (1, 2)

def foo(i, j):
    return i + j
print 3 |> foo(1)  #: 4

#%% typeof_definitions,barebones
a = 10
def foo(a)->type(a): return a
print(foo(5).__class__.__name__)  #: int

b: type(a) = 1
print(b.__class__.__name__) #: int

#%% multi_error,barebones
# TODO in new parser!
# a = 55
# print z  # name 'z' is not defined
# print(a, q, w)  # name 'q' is not defined
# print quit  # name 'quit' is not defined

#%% static_unify,barebones
def foo(x: Callable[[1,2], 3]): pass  #! Callable cannot take static types

#%% static_unify_2,barebones
def foo(x: List[1]): pass  #! expected type expression

#%% expr,barebones
a = 5; b = 3
print a, b  #: 5 3

#%% delayed_instantiation_correct_context,barebones
# Test timing of the statements; ensure that delayed blocks still
# use correct names.
def foo():
    l = []

    s = 1  # CH1
    if isinstance(l, List[int]):  # delay typechecking this block
        print(s)  #: 1
        # if this is done badly, this print will print 's'
        # or result in assertion error
    print(s)  #: 1

    s = 's'  # CH2
    print(s)  #: s

    # instantiate l so that the block above
    # is typechecked in the next iteration
    l.append(1)
foo()

# check that this does not mess up comprehensions
# (where variable names are used BEFORE their declaration)
slice_prefixes = [(start, end)
                    for start, end in [(1, 2), (3, 4)]]
print(slice_prefixes)  #: [(1, 2), (3, 4)]
