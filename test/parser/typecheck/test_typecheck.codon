#%% pass,barebones
pass

#%% print,barebones
print 1,
print 1, 2  #: 1 1 2

print 1, 2  #: 1 2
print(3, "4", sep="-", end=" !\n") #: 3-4 !

print(1, 2) #: 1 2
print (1, 2) #: (1, 2)

def foo(i, j):
    return i + j
print 3 |> foo(1)  #: 4

#%% typeof_definitions,barebones
a = 10
def foo(a)->type(a): return a
print(foo(5).__class__.__name__)  #: int

b: type(a) = 1
print(b.__class__.__name__) #: int

#%% multi_error,barebones
# TODO in new parser!
# a = 55
# print z  # name 'z' is not defined
# print(a, q, w)  # name 'q' is not defined
# print quit  # name 'quit' is not defined

#%% static_unify,barebones
def foo(x: Callable[[1,2], 3]): pass  #! Callable cannot take static types

#%% static_unify_2,barebones
def foo(x: List[1]): pass  #! expected type expression

#%% expr,barebones
a = 5; b = 3
print a, b  #: 5 3

#%% delayed_instantiation_correct_context,barebones
# Test timing of the statements; ensure that delayed blocks still
# use correct names.
def foo():
    l = []

    s = 1  # CH1
    if isinstance(l, List[int]):  # delay typechecking this block
        print(s)  #: 1
        # if this is done badly, this print will print 's'
        # or result in assertion error
    print(s)  #: 1

    s = 's'  # CH2
    print(s)  #: s

    # instantiate l so that the block above
    # is typechecked in the next iteration
    l.append(1)
foo()

# check that this does not mess up comprehensions
# (where variable names are used BEFORE their declaration)
slice_prefixes = [(start, end)
                    for start, end in [(1, 2), (3, 4)]]
print(slice_prefixes)  #: [(1, 2), (3, 4)]

def foo():
    # fn itself must be delayed and unbound for this to reproduce
    fn = (lambda _: lambda x: x)(None)

    zizzer = 1
    y = fn(zizzer)
    print(y)  #: 1

    zizzer = 's'
    y = fn(zizzer)
    print(y)  #: s
foo()

#%% do_not_resolve_default_generics_on_partial,barebones
def coerce():
    def foo(): pass
    def bar(T1: type, I1: type = T1):
        print(T1 is I1)  #: False
        foo()
    bar(int, I1=Int[64]) # creates bar=bar(foo,...) first
coerce()

#%% compile_error_realization,barebones
def ctx():
    def foo(): compile_error("bah!")
    def bar(err: Static[bool]):
        if err: foo()
        else: print("ok")
    bar(False)
ctx()  #: ok

#%% stdlib_name_clash,barebones
def bar(j):
    # captures stdlib range, not foo's range
    for i in range(*j): print(i)
def foo(range):
    bar(range)
foo((1, 2))  #: 1
